
# 🎟️ Sistema de Bilhetagem - Itaú Case

Este projeto consiste em um sistema de bilhetagem distribuído, baseado em **microserviços** e **arquitetura hexagonal**, com foco em princípios de segurança (OWASP), boas práticas de design (Clean Architecture, SOLID, 12 Factors), e integração entre serviços.

Foi desenvolvido como entrega para o **case técnico Itaú**.

## 🌟 Arquitetura e Decisões

A arquitetura escolhida foi **microserviços com arquitetura hexagonal** para cada serviço, com os seguintes motivos:

✅ Separação clara de domínios de negócio (DDD)
✅ Evolução e manutenção desacoplada
✅ Testes unitários e de integração mais fáceis
✅ Melhor suporte a escalabilidade
✅ Cada serviço com banco próprio (PostgreSQL no compose, SQLite local)

Todos os serviços seguem:

- **Clean Architecture** — domínio isolado da infraestrutura
- **Princípios SOLID** e 12 Factors
- Práticas de segurança OWASP (validação, controle de erros)
- Integração por REST entre serviços
- API OpenAPI (Swagger gerado automaticamente)

**Orquestração:** GitHub Actions (CI/CD) — não incluso na entrega, mas documentado.

**Banco:** PostgreSQL ou SQLite (para testes locais)

**Backend:** Python 3.12 + FastAPI + SQLAlchemy

**PDF:** FPDF (geração de ingressos)

**Outros:** Makefile e scripts utilitários para facilitar o uso.

---

## 🧱 Serviços

- **user-service**: CRUD de usuários
- **event-service**: CRUD de eventos
- **product-service**: Produtos complementares
- **ticket-service**: Controle de ingressos + geração de PDF
- **reservation-service**: Reservas de ingressos, com expiração automática
- **order-service**: Orquestra a finalização de pedidos e confirmação de reservas

---

## 🗺️ Fluxo de Compra

1️⃣ Usuário e evento são criados  
2️⃣ Tickets são cadastrados para o evento  
3️⃣ Reservas são feitas (temporárias)  
4️⃣ Pedido é finalizado (confirma reservas + gera ticket PDF)

---

## ⚙️ Como rodar o projeto

### Localmente (SQLite, sem docker)

```bash
# Instalar dependências
make prepare

# Rodar todos os serviços (6 serviços)
make run
```

### Com PostgreSQL (docker-compose)

```bash
make up_db
make up_services
```

---

## 🚀 Endpoints (exemplos)

### `user-service`

```http
GET /users/
GET /users/{id}
POST /users/ { name, email }
```

### `event-service`

```http
GET /events/
POST /events/ { title, location, date }
```

### `ticket-service`

```http
POST /tickets/ { event_id, quantity, price }
POST /tickets/from-order { payload do pedido }
GET /tickets/{id}/pdf
```

### `reservation-service`

```http
POST /reservations/ { user_id, ticket_id, quantity }
GET /reservations/user/{user_id}
```

### `order-service`

```http
POST /orders/ { user_id, event_id, items, products, total_price }
GET /orders/
GET /orders/{id}
```

---

## 🛡️ Segurança

✅ Validação de payloads com Pydantic  
✅ SQL Injection safe (SQLAlchemy ORM)  
✅ Sem exposição de dados sensíveis  
✅ Logs protegidos  
✅ Integração entre serviços autenticada por IP local (exemplo)

---

## 🛠️ Tecnologias

- Python 3.12
- FastAPI
- SQLAlchemy
- SQLite / PostgreSQL
- FPDF (geração de PDF de ingressos)
- qrcode
- Makefile + Bash Scripts

---

## 🎁 Como rodar os testes

```bash
make test
```

---

## 🎯 Conclusão

Essa arquitetura foi escolhida para permitir alta coesão de domínios e separação de responsabilidades, e garantir que a manutenção e evolução sejam facilitadas.  
A entrega permite rodar 100% local (SQLite) ou com docker-compose (PostgreSQL).

Caso de dúvidas, você pode me contatar!  
🤘 Gabriela Mota